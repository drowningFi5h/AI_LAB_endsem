\documentclass[11pt]{article}
\usepackage[hmargin=1in,vmargin=1in]{geometry}
\usepackage{xcolor}
\usepackage{algorithm2e}
\usepackage{tikz}
\usepackage{forest}
\usepackage{algorithm2e}
\usepackage{algorithm}
\usepackage{hyperref}
\usepackage{amsmath}

\usetikzlibrary{positioning}
\usepackage{amsmath,amssymb,amsfonts,url,sectsty,framed,tcolorbox,framed}
\newcommand{\pf}{{\bf Proof: }}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}
\newcommand{\qed}{\hfill \rule{2mm}{2mm}}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\noindent
\rule{\textwidth}{1pt}
\begin{center}
{\bf [CS304] Introduction to Cryptography and Network Security}
\end{center}
Course Instructor: Dr. Dibyendu Roy \hfill Winter 2023-2024\\
Scribed by: Sanidhya Kumar (202151138) \hfill Lecture (Week 11)
\\
\rule{\textwidth}{1pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%write here

\section{The Discrete Logarithm Problem (DLP)}
The challenge of the Discrete Logarithm Problem lies in finding an integer $x$ within the range $0 \leq x \leq (n-1)$ such that $\alpha^x = \beta$, given a cyclic group $G$ of order $n$, its generator $\alpha$, and an element $\beta \in G$.\\
\newline
To compute $a$ when given $g$ and $g^a$, an exhaustive search method can be employed. By iterating a loop from $i = 1$ to $i = n$, the size of the group ($n$), we calculate $g^i$. If $g^i = g^a$, we have found the desired result. The complexity of this approach corresponds to the size of the group. Alternatively, the Baby-Step Giant-Step Algorithm offers a solution to the Discrete Logarithm Problem with a complexity of approximately $\sqrt{n}$.
\subsection{Baby-Step Giant-Step Algorithm}

Initially, we calculate $m = \sqrt{n}$. Since $n$ represents the order of the group and $\alpha$ serves as the generator of the group, it follows that $\alpha^n = 1$. Now, assuming $\beta = \alpha^x$, we can express $x$ using the Division Algorithm as follows:
\begin{center}
    $x = i \cdot m + j$, where $0 \leq i < j$\\
    \vspace{1mm}
    Thus, $\alpha^x = \alpha^{i\cdot m} \cdot \alpha^j $\\
    \vspace{1mm}
    Implying $\beta = \alpha^{i\cdot m} \cdot \alpha^j $
\end{center}
Shifting $\alpha^{i\cdot m}$ to the right side, we obtain:
\begin{center}
    $\alpha^j = \beta {(\alpha^{im})}^{-1}$\\
    \vspace{1mm}
    $\alpha^j = \beta {(\alpha^{-m})}^i$
\end{center}
Now, instead of determining $x$, the focus shifts to finding $i$ and $j$, both of which range within $m = \sqrt{n}$. We aim to accomplish this without significantly escalating complexity.\\
\newline
Formalizing the algorithm, the input comprises the generator $\alpha$ of cyclic group G, the order of group G ($n$), and $\beta \in G$. The output is the discrete logarithm $x = \log_{\alpha}{\beta}$. The procedure is outlined below:
\begin{enumerate}
    \item Assign $m \leftarrow \lceil \sqrt{n} \rceil$
    \item Create a table T with entries $j, \alpha^j \, 0 \leq j < m$. Sort T based on $\alpha^j$ values.
    \item Compute $\alpha^{-m}$ and set $\gamma \leftarrow \beta$
    \item For $i = 0$ to $i = (m-1)$, perform:
    \begin{itemize}
        \item Check if $\gamma$ is the second component of any entry in T.
        \item If $\gamma = \alpha^j$, then compute $x = i\cdot m + j$
        \item Update $\gamma$ as $\gamma = \gamma \cdot \alpha^{-m}$
    \end{itemize}
\end{enumerate}
The table can be generated offline, necessitating $O(\sqrt{n})$ space. The runtime of the algorithm involves $O(\sqrt{n})$ multiplications. Sorting the table requires $O(\sqrt{n} \cdot \log(\sqrt{n})) \implies O(\sqrt{n} \cdot \log(n))$ time.

\subsection*{Example}
Let us consider an example to understand this algorithm more clearly.\\\\
\textbf{Given -}
\begin{align*}
&G = \mathbb{Z}_{113} \quad (p=113) \\
&\alpha = 3 \\
&|G| = 112 \quad (\text{where } |G| \text{ is the order of the group})\\
&\beta = 57 \\
\end{align*}
\noindent
To find $x$ such that $3^x = 57$ and $0 \leq x \leq \sqrt{112}$:\\\\
\textbf{Solution -}\\\\
\textbf{Step 1:}
Find $m$ which is $\lceil \sqrt{n} \rceil = \lceil \sqrt{112} \rceil \approx 11$\\\\
\textbf{Step 2:}
Find $(j, \alpha^j \mod p)$ such that $0 \leq j \leq 11$

\begin{align*}
\begin{array}{c|ccccccccccc}
j & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
\hline
(3^j \mod 113) & 1 & 3 & 9 & 27 & 81 & 17 & 51 & 40 & 7 & 21 & 63 \\
\end{array}
\end{align*}\\\\
\textbf{Step 3:}
Sort the table based on $3^j \mod 113$ value

\begin{align*}
\begin{array}{c|cccccccccc}
j & 0 & 1 & 8 & 2 & 5 & 9 & 3 & 7 & 6 & 10 & 4 \\
\hline
3^j \mod 113 & 1 & 3 & 7 & 9 & 17 & 21 & 27 & 40 & 51 & 63 & 81 \\
\end{array}
\end{align*}\\\\
\textbf{Step 4:}
Find $\alpha$ inverse: $3^{-11} = (3^{-1})^{11} = (38)^{11} \mod 113 = 58$
Note: Inverse is under modulo 113 and is calculated using the extended Euclidean algorithm.\\\\
\textbf{Step 5:}
Calculate $r = \beta \cdot \alpha^{-mi} \mod 113$ for $i = 0, 1, 2, \dots, 10$

\begin{align*}
\begin{array}{c|cccccccccc}
i & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
\hline
r = 57 \cdot (58)^i & 57 & 29 & 100 & 37 & 112 & 55 & 26 & 39 & 2 & 3 & \text{no-need} \\
\end{array}
\end{align*}

\begin{center}
    
$\beta \cdot \alpha^{-9m} = 3 = \alpha^1$

$\beta \cdot \alpha^{-9 \cdot 11} = \alpha^1$

Hence, $i = 9$ and $j = 1$

Now, $x = im + j$

$x = 9 \cdot 11 + 1 = 100$
\end{center}
Hence,\textbf{ $x = 100$, which is the solution.}




\section{ElGamal Public Key Cryptosystem}
ElGamal Public Key Cryptosystem operates similarly to RSA but relies on the Discrete Log Problem for security. The following steps outline the encryption and decryption processes in detail:

\begin{enumerate}
    \item Choose a prime number $p$.
    \item Define the group $(Z_p^*, *_p)$.
    \begin{center}
        $Z_p^* = \{1,2,3,\hdots,(p-1)\}$\\
        $x *_p y = x * y \ (\text{mod} \ p)$\\
    \end{center}
    If $x \in Z_p^*$, then $\text{gcd}(x, p) = 1$, implying the existence of the multiplicative inverse of $x$ modulo $p$.
    \item Choose a primitive element $\alpha \in Z_p^*$, also referred to as the generator of $Z_p^*$.
    \begin{center}
        $Z_p^*$ forms a cyclic group\\
        $Z_p^* = \langle \alpha \rangle$\\
    \end{center}
    \item The plaintext space is $Z_p^*$, and the key space is $\{(p, \alpha, a, \beta), \beta = \alpha^a \ (\text{mod} \ p)\}$.
    \item The public key consists of $\{P, \alpha, \beta\}$, and the secret key is $\{a\}$.
    \item Select a random number $x \in Z_{p-1}$, keeping it secret.
    \item \textbf{Encryption:} The encryption algorithm yields a ciphertext tuple.
    \begin{center}
        $e_K(m, x) = (y_1, y_2)$\\
        $y_1 = \alpha^x \ (\text{mod} \ p)$\\
        $y_2 = m \cdot \beta^x \ (\text{mod} \ p)$
    \end{center}
    \item \textbf{Decryption:} The decryption process is as follows,
    \begin{center}
        $d_K(y_1, y_2) = y_2 \cdot {(y_1^a)}^{-1} \ (\text{mod} \ p) = m$\\
        $y_1^a = {(\alpha^x)}^a \ (\text{mod} \ p) = \beta^x \ (\text{mod} \ p)$\\
        ${y_2 \cdot (y_1^a)}^{-1} = m \cdot \beta^x \cdot {\beta^x}^{-1} \ (\text{mod} \ p) = m \ (\text{mod} \ p)$\\
    \end{center}
    The presence of randomness in the ciphertext stems from the randomly chosen $x$.
\end{enumerate}
\noindent
The public key is $\{\beta, \alpha, p\}$. The challenge lies in finding $a$ from $\beta$ and $\alpha$ (the Discrete Log Problem). However, if we possess the ciphertext and
\begin{center}
    $y_1 = \alpha^x$,
\end{center}
computing $\alpha^{ax}$ from $\beta = \alpha^a$ and $\alpha^x$ would enable us to derive the message $m$ without needing to determine $a$ or $x$. This would break the ElGamal Encryption, yet it wouldn't guarantee solving the Discrete Log Problem. This scenario mirrors the Diffie-Hellman Problem. If one can compute $g^{ab}$ from $g^a$ and $g^b$, the Diffie-Hellman Key Exchange Algorithm is compromised, but the Discrete Log Problem remains unsolved.

\subsection*{Example}
Let us consider an example of ElGamal to understand this algorithm more clearly.\\\\
Given common information \textbf{(Public Information)}:
\[
P = 7, \quad \alpha = 4, \quad \beta = 4^3 \equiv 1 \ (\text{mod} \ 7)
\]\\\\
\textbf{Alice's Side:}
\[
\begin{align*}
\text{Message} \ M &= 5 \\
x &= 2 \\
y_1 &= \alpha^x = 4^2 \equiv 2 \ (\text{mod} \ 7) \\
y_2 &= M \cdot \beta^x = 5 \ (\text{mod} \ 7)
\end{align*}
\]\\\\
Now, Alice sends \((y_1, y_2)\) to Bob.\\\\
\textbf{Bob's Side:}
\[
\begin{align*}
\text{Bob's secret key} \ a &= 3 \\
\text{Bob receives} \ (y_1, y_2) \ \text{from Alice} \\
\text{Bob calculates:} \\
y_2 \cdot (y_1^a)^{-1} &= 5 \cdot (2^3)^{-1} \\
&= 5 \cdot (8)^{-1} \\
&= 5 \cdot (1)^{-1} \ (\text{calculate inverse modulo } P \ \text{using extended Euclidean algorithm}) \\
&= 5 \\
&= M \ (\text{original message by Alice})
\end{align*}
\]\\\\
\textbf{Note:} Everything is under modulo \( P \) (7 here).

\section{Kerberos (Version 4)}
Kerberos is a network security protocol designed to authenticate service requests among trusted hosts over potentially untrusted networks, such as the internet. It relies on secret-key cryptography and a trusted third-party system to validate client-server interactions and authenticate user identities. It is important to note that this protocol uses Symmetric Key Cryptography at its core.\\
\newline
The Kerberos protocol involves three key entities:
\begin{itemize}
    \item Ticket-Granting Server (TGS)
    \item Authentication Server (AS)
    \item Verifier (V)
\end{itemize}
\noindent
\\The authentication process involves communication between a client \(C\) and various servers, namely the Authentication Server (AS), the Ticket Granting Server (TGS), and a Verifier (\(V\)). Below is a step-by-step description of the communication flow:

\begin{enumerate}
    \item The client initiates communication by logging into the server and sending the following details to the Authentication Server:
    \begin{align*}
        C &\rightarrow AS: {ID}_c || {ID}_{TGS} || {TS}_1 \\
        {ID}_c &\rightarrow \text{Identity of Client} \\
        {ID}_{TGS} &\rightarrow \text{Identity of TGS} \\
        {TS}_1 &\rightarrow \text{Timestamp}
    \end{align*}

    \item The AS will receive the information and send an encrypted message back to the client with the following information. AS performs symmetric key encryption using the key ${SK}_c$, which is shared between the AS and the client.
    \begin{center}
        $AS \rightarrow C: E({SK}_c, [{SK}_{c,TGS} \ || \ {ID}_{TGS} \ || \ {TS}_2 \ || \ {Lifetime}_2 \ || \ {Ticket}_{TGS}])$\\
        \vspace{1mm}
        ${SK}_{c,TGS} \rightarrow $key used for communication between Client and TGS\\
        ${Lifetime}_2 \rightarrow$ for how long this ticket/data will be valid\\      
    \end{center}
    $ID_{TGS}$ and $TS_2$ are ID of TGS and timestamp as earlier. The ticket is generated by AS and contains the following information.
    \begin{center}
        ${Ticket}_{TGS} = E({SK}_{TGS}, [{SK}_{c,TGS} \ || \ {ID}_c \ || \ {AD}_c \ || \ {ID}_{TGS} \ || \ {Lifetime}_2])$\\
        \vspace{1mm}
        ${AD}_c \rightarrow $ Address of client
    \end{center}
    As it can be seen the ${Ticket}_{TGS}$ is encrypted using the key ${SK}_{TGS}$. It is the key used for communication between AS and TGS and it is not known to any other party.\\
    The client will receive the response from the AS and will be able to decrypt it as it was encrypted using ${SK}_c$, which is shared between client and AS. The client will recieve the following information:
    \begin{center}
        $[{SK}_{c,TGS}, \ {ID}_{TGS}, \ {TS}_2, \ {Lifetime}_2, \ {Ticket}_{TGS}]$
    \end{center}
    The client will receive the ticket but will not be able to decrypt it as client doesn't have ${SK}_{TGS}$. The client will also receive the key ${SK}_{c,TGS}$ which is the shared secret key between client and TGS. This secret key is also called as session key. When you establish a session in server, you get a session key for encrypted communication.

    \item With the session key \({SK}_{c,TGS}\), the client initiates communication with the TGS:
    \begin{align*}
        C &\rightarrow TGS: {ID}_v || {Ticket}_{TGS} || {Authenticator}_c \\
        {Authenticator}_c &= E({SK}_{c,TGS}, [{ID}_c || {AD}_c || {TS}_3])
    \end{align*}

    \item The TGS decrypts the ticket and authenticator to verify the client's identity and sends back encrypted information:
    \begin{align*}
        TGS &\rightarrow C: E({SK}_{c,TGS}, [{SK}_{c,v} || {ID}_v || {TS}_4 || {Ticket}_v])
    \end{align*}
    The ticket \(Ticket_v\) includes information encrypted using the key \({SK}_v\), known only to TGS and the verifier.

    \item The client sends the ticket and a fresh authenticator to the verifier:
    \begin{align*}
        C &\rightarrow V: {Ticket}_v || {Authenticator}_c
    \end{align*}

    \item The verifier decrypts the received data to authenticate the client:
    \begin{align*}
        V &\rightarrow C: E({SK}_{c,v}, [{TS}_5 + 1])
    \end{align*}
\end{enumerate}
\noindent
\\\textbf{Note} - Refer Cryptography and Network Security - Principles and Practice by William Stallings for further reading.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%END
 
\end{document}