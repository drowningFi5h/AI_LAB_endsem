\documentclass[11pt]{article}
\usepackage[hmargin=1in,vmargin=1in]{geometry}
\usepackage{xcolor}
\usepackage{algorithm2e}
\usepackage{tikz}
\usepackage{forest}
\usepackage{algorithm2e}
\usepackage{algorithm}
\usepackage{hyperref}


\usetikzlibrary{positioning}
\usepackage{amsmath,amssymb,amsfonts,url,sectsty,framed,tcolorbox,framed}
\newcommand{\pf}{{\bf Proof: }}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}
\newcommand{\qed}{\hfill \rule{2mm}{2mm}}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\noindent
\rule{\textwidth}{1pt}
\begin{center}
{\bf [CS304] Introduction to Cryptography and Network Security}
\end{center}
Course Instructor: Dr. Dibyendu Roy \hfill Winter 2023-2024\\
Scribed by: Sanidhya Kumar (202151138) \hfill Lecture (Week 7 \& 8)
\\
\rule{\textwidth}{1pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%write here

\section{Hash Function}

In the field of cryptography, a hash function is a mathematical process that accepts an input, or "message", and outputs a fixed-length string of bytes, usually in the form of a hash value or hash code. Often called a digest, the output is a distinct representation of the input data. Fast and effective hash functions offer a safe and dependable means of confirming the integrity of data, authenticating communications, and creating digital signatures.\\\\A hash family is a four-tuple $(X, Y, K, H)$, where:
\begin{enumerate}
    \item $X$ is a set of possible messages.
    \item $Y$ is a finite set of possible message digests or authentication tags (or just tags).
    \item $K$, the keyspace, is a finite set of possible keys.
    \item For each $k \in K$, there is a hash function $h_k \in H$, where $h_k : X \rightarrow Y$.
\end{enumerate}
\vspace{5pt}
While $Y$ is always a finite set in the definition above, it may not always be a finite set. The function is sometimes referred to as a compression function if $X$ is a finite set and $|X| > |Y|$. In this case, we'll assume the more favorable circumstance. $|X| > 2^{|Y|}$.

\subsection{Types of Hash Functions}

\begin{figure}[h]
    \centering
    \begin{tikzpicture}[
        level 1/.style={sibling distance=4cm},
        level 2/.style={sibling distance=2cm},
        every node/.style={draw, rectangle, minimum width=3cm, minimum height=1cm}
    ]
    \node {Types of Hash Functions}
        child {node {Keyed Hash Function}}
        child {node {Unkeyed Hash Function}};
    \end{tikzpicture}
    \caption{Types of Hash Functions}
    \label{fig:hash-functions}
\end{figure}


\subsubsection{Unkeyed Hash Function}
A function $h : X \rightarrow Y$, where $X$ and $Y$ are the same, is an unkeyed hash function. An unkeyed hash function can be conceptualized as a hash family where $|K| = 1$, or one with a single potential key. The output of an unkeyed hash function is commonly referred to as a ''message digest.''

\subsubsection{Keyed Hash Function}
If the key is involved in the computation of hashed value then that hash function is known as keyed hash function. The output of a keyed hash function is referred to as a ''tag.''

\subsection{Legitimacy Under Hash Function}
If $h(x) = y$, then a pair $(x, y) \in X \times Y$ is considered legitimate under a hash function $h$. In this case, $h$ may be an unkeyed or keyed hash function. In this chapter, we mainly cover techniques to stop an opponent from creating specific kinds of valid pairs.\\\\
Let $F_{X,Y}$ denote the set of all functions from $X$ to $Y$. Suppose that $|X| = N$ and $|Y| = M$. Then it is clear that $|F_{X,Y}| = M^N$. Any hash family $F$ consisting of functions with domain $X$ and range $Y$ can be considered to be a subset of $F_{X,Y}$, i.e., $F \subseteq F_{X,Y}$. Such a hash family is termed an $(N, M)$-hash family.

\subsection{Ideal Hash Function}
Let $h : P \rightarrow S$. $h$ is ideal if, given $x \in P$, to find $h(x)$, you either have to apply $h$ on $x$ or you have to look into the table corresponding to $h$.

\subsection{The Three Famous Problems}
\vspace{15pt}
\begin{center}
 \begin{forest}
for tree={rectangle, draw, l sep=15pt}
[The Three Famous Problems
    [Pre-image Finding Problem]
    [2nd Pre-image Finding Problem, l sep=10pt]
    [Collision Finding Problem]
]
\end{forest}   
\end{center}

\subsubsection{Solution for Pre-image Finding Problem}
Given $y \in Y$, $h : X \rightarrow Y$, $|Y| = M$, find $x \in X$.

\begin{algorithm}[H]
\SetAlgoLined
\KwIn{$X_0 \subseteq X$ such that $|X_0| = Q$}
\KwOut{An element $x \in X_0$ such that $h(x) = y$}
\ForEach{$x \in X_0$}{
    Compute $y' = h(x)$\;
    \If{$y' = y$}{
        \Return{$x$}\;
    }
}
\caption{Finding $x$ such that $h(x) = y$}
\end{algorithm}
\vspace{5pt}
\noindent
This is also known as the exhaustive search method for finding the pre-image $x$ given $y$. The probability of the above algorithm returning the correct pre-image is inversely proportional to the time complexity.\\\\
The provided equations analyze the probability and time complexity of finding pre-images in set X0. They demonstrate that as the size of X0 increases, both the probability and time complexity decrease, resulting in a more efficient pre-image search.\\\\
For example, $X_0 = \{x_1, x_2, \ldots, x_q\}$:
\begin{align*}
    P(\text{event } E_i) &= P(h(x_i) = y) = 1 - \frac{1}{M} \quad (\text{as 1 out of the length of } y \text{ will be the outcome}) \\
    P(\text{event } E_i') &= 1 - P(E_i) = 1 - \frac{1}{M} \\
    P(E_1 \cup E_2 \cup \ldots \cup E_q) &= 1 - P(E_1' \cap E_2' \cap \ldots \cap E_q') \\
    &= 1 - P(E_1') \cdot P(E_2') \cdot \ldots \cdot P(E_q') \\
    &= 1 - \left(1 - \frac{1}{M}\right)^q \\
    &= \frac{Q}{M}
\end{align*}
Therefore, complexity $= O(M/Q) = O(M)$, i.e., the bigger set of $X_0$, the greater the probability and the lesser the time complexity to find the pre-image.

\subsubsection{Solution for 2nd Pre-image Finding Problem}
Given $x$, $h(x)$, find $x'$ such that $h(x) = h(x')$, where $X_0$ is a subset of $X$ without $x$, and $|X_0| = Q$. Therefore, we can use the same algorithm as above and perform an exhaustive search. Time complexity $= O(M)$.

\subsubsection{Solution for Collision Finding Problem}
We have $h : X \rightarrow Y$, where $|Y| = M$. We need to find $x'$ and $x$ such that $x' \neq x$ and $h(x) = h(x')$.\\

\begin{algorithm}[H]
\SetAlgoLined
\KwIn{$X_0 \subseteq X - \{x\}$ with $|X_0| = Q$}
\KwOut{A pair of elements $\{x, x'\}$ such that $h(x) = h(x')$ and $x \neq x'$}
\ForEach{$x' \in X_0$}{
    Compute $y_x = h(x)$ and $y_{x'} = h(x')$\;
    \If{$y_x = y_{x'}$}{
        \Return{$\{x, x'\}$}\;
    }
}
\caption{Finding a pair of elements $\{x, x'\}$ with equal hash values}
\end{algorithm}
\vspace{5pt}
\noindent
Let $E_i$ be the event that $h(x_i)$ is not equal to any of $\{h(x_1), h(x_2), \ldots , h(x_{i-1})\}$.
\begin{align*}
    \text{For } i = 1, &\quad Pr[E_1] = 1 \quad (\text{since } h(x_1) \text{ should not belong to the empty set}). \\
    \text{For } i = 2, &\quad \text{given } E_1, Pr[E_2|E_1] = \frac{M - 1}{M} \quad (\text{mapping to all elements except } h(x_1)). \\
    \text{Similarly, for } i = 3, &\quad \text{given } E_1 \cap E_2, Pr[E_3|E_1 \cap E_2] = \frac{M - 2}{M}. \\
    \text{In general, for } i = k, &\quad \text{given } E_1 \cap E_2 \cap \ldots \cap E_{k-1}, Pr[E_k|E_1 \cap E_2 \cap \ldots \cap E_{k-1}] = \frac{M - (k-1)}{M}.
\end{align*}
\noindent\\
Therefore, the collision probability $\epsilon$ is given by:
\[
\epsilon = 1 - Pr[E_1 \cap E_2 \cap \ldots \cap E_Q]' = 1 - \left(\frac{M - 1}{M} \cdot \frac{M - 2}{M} \cdot \ldots \cdot \frac{M - (Q - 1)}{M}\right).
\]
Solving for $Q$:
\[
Q = \sqrt{2 \ln \left(\frac{1}{1 - \epsilon}\right) \sqrt{M}}.
\]
Hence, the value of $Q$ is approximately the square root of $M$.

\section{Compression Function}

$h:\{0,1\}^{m+t}\rightarrow\{0,1\}^m$ is a hash function that takes inputs of length $m+t$ and produces outputs of length $m$. The goal is to construct a function $H:\{0,1\}^*\rightarrow\{0,1\}^m$ from $h$, where $H$ takes inputs of any length and produces outputs of length $m$.\\\\
$h:\{0,1\}^{m+t}\rightarrow\{0,1\}^m$\\
$Second preimage,preimage\rightarrow O(2^m)$\\
$Collision\rightarrow O(2^{m/2})$
\begin{algorithm}
\caption{Compress}
\label{alg:iterated-hash}
Suppose that Compress: \{0,1\}^{m+t}\rightarrow\{0,1\}^m$ is a compression function.\\
\textbf{Input:}
\begin{itemize}
    \item $x$ : An input string of length greater than m + t + 1.
\end{itemize}

\textbf{Output:}
\begin{itemize}
    \item $h(x)$ : The hash value of the input string $x$.
\end{itemize}
\textbf{Process}
\begin{itemize}
    \item Pad $x$ with 0s to get a string $y$ with a length divisible by $t$.
    \item Let $y = y_1 || y_2 || ... || y_r$ where each $y_i$ has length $t$ (except possibly the last one).
    \item Initialize $z_0 \leftarrow IV$.\\
            For $i = 1$ to $r$ do:\\
        $z_i \leftarrow compress(z_{i - 1} || y_i)$
        
\end{itemize}
\end{algorithm}

\section{Merkle-Damgard Construction}
The Merkle-Damgard construction has the property that the resulting hash function satisfies desirable security properties, such as collision resistance, provided that the compression function does. It helps in constructing a hash function from a compression function.\\\\
Suppose \textbf{Compress:} $\{0, 1\}^{(m + t)} \rightarrow \{0, 1\}^m$ is a collision-resistant compression function, where $t \geq 1$. So \textbf{compress} takes $m + t$ input bits and produces $m$ output bits. We will use \textbf{compress} to construct a collision-resistant hash function $h : X \rightarrow \{0, 1\}^m$; the hash function $h$ takes any finite bitstring of length at least $m + t + 1$ and creates a message digest that is a bitstring of length $m$.\\\\\\
\textbf{Merkle-Damg√•rd Hash Construction}\\\\
\textbf{Input:} $x$: Input message\\\\
\textbf{Output:} $h(x)$: Hash value of $x$

\begin{enumerate}
    \item[] \textbf{Step 1:} Calculate the length of the input message:
    \begin{equation*}
        n = |x| \quad \text{(Length of input message)}
    \end{equation*}
    
    \item[] \textbf{Step 2:} Determine the number of blocks:
    \begin{equation*}
        K = \left\lfloor \frac{n}{t-1} \right\rfloor \quad \text{(Number of blocks)}
    \end{equation*}
    
    \item[] \textbf{Step 3:} Calculate the padding size:
    \begin{equation*}
        d = K(t-1) - n \quad \text{(Padding size)}
    \end{equation*}
    
    \item[] \textbf{Step 4:} For $i = 1$ to $K-1$, set $y_i = x_i$.
    
    \item[] \textbf{Step 5:} Pad the last block:
    \begin{equation*}
        y_K = x_K || 0^d \quad \text{(Pad last block)}
    \end{equation*}
    
    \item[] \textbf{Step 6:} Convert the padding size to binary representation:
    \begin{equation*}
        y_{K+1} = \text{binary}(d) \quad \text{(Binary representation of padding size)}
    \end{equation*}
    
    \item[] \textbf{Step 7:} Initialize the state:
    \begin{equation*}
        Z_1 = 0^{m+1} || y_1 \quad \text{(Initialize state)}
    \end{equation*}
    
    \item[] \textbf{Step 8:} Compress the initial state:
    \begin{equation*}
        g_1 = \text{compress}(Z_1) \quad \text{(Compress initial state)}
    \end{equation*}
    
    \item[] \textbf{Step 9:} For $i = 1$ to $K$, update the state and compress it:
    \begin{align*}
        & Z_{i+1} = g_i || 1 || y_{i+1} \quad \text{(Update state)} \\
        & g_{i+1} = \text{compress}(Z_{i+1}) \quad \text{(Compress state)}
    \end{align*}
    
    \item[] \textbf{Step 10:} Final hash value:
    \begin{equation*}
        h(x) = g_{K+1} \quad \text{(Final hash value)}
    \end{equation*}
\end{enumerate}

\section{Secure Hash Functions (SHA)}


The Secure Hash Algorithm (SHA) was devised by the National Institute of Standards and Technology (NIST) and published as a federal information processing standard (FIPS 180) in 1993. A revised edition, known as SHA-1, was released as FIPS 180-1 in 1995.\\\\
There exist three variants of SHA: SHA-160, SHA-256, and SHA-512, generally denoted as $SHA: \{0,1\}^* \rightarrow \{0,1\}^n$.

\subsection{Types of SHA}

\begin{forest}
  for tree={
    parent anchor=south,
    child anchor=north,
    align=center,
    edge path={
      \noexpand\path[\forestoption{edge}]
      (!u.parent anchor) -- +(0,-5pt) -|   
      (.child anchor)\forestoption{edge label};
    },
    if n children=0{tier=word}{}
  }
  [\textbf{Secure Hash Functions (SHA)}
    [\textbf{SHA-1}\\
      Message Size: $<2^{64}$ bits\\
      Block Size: 512 bits\\
      Word Size: 32 bits\\
      Message Digest Size: 160 bits\\
    ]
    [\textbf{SHA-256}\\
      Message Size: $<2^{64}$ bits\\
      Block Size: 512 bits\\
      Word Size: 32 bits\\
      Message Digest Size: 256 bits\\
    ]
    [\textbf{SHA-512}\\
      Message Size: $<2^{128}$ bits\\
      Block Size: 1024 bits\\
      Word Size: 64 bits\\
      Message Digest Size: 512 bits\\
    ]
  ]
\end{forest}

\subsection{SHA I in Detail}

For SHA I, the message size is limited to $2^{64}$ bits. If $|x| \leq 2^{64}$, padding is applied such that $y$ becomes a multiple of 512 bits by appending a single '1' followed by necessary '0's.\\\\
The SHA I algorithm involves four distinct functions and five constants, along with four keys and five initial hash values.\\
\begin{algorithm}[H]
\caption{SHA I Algorithm}
\KwIn{$x$: Input message}
\KwOut{$h(x)$: Hash value of $x$}
\BlankLine
$n \gets |x|$ ;
$K \gets \left\lfloor \frac{n}{t-1} \right\rfloor$ ;
$d \gets K(t-1) - n$ ;
\For{$i = 1$ to $K-1$}{
$y_i \gets x_i$ ;
}
$y_K \gets x_K || 0^d$ ;
$y_{K+1} \gets \text{binary}(d)$ ;
$Z_1 \gets 0^{m+1} || y_1$ ;
$g_1 \gets \text{compress}(Z_1)$ ;
\For{$i = 1$ to $K$}{
$Z_{i+1} \gets g_i || 1 || y_{i+1}$ ;
$g_{i+1} \gets \text{compress}(Z_{i+1})$ ;
}
$h(x) \gets g_{K+1}$ ;
\Return{$h(x)$} ;
\end{algorithm}

\section{Message Authentication Code (MAC)}

A Message Authentication Code (MAC) serves as a cryptographic tool ensuring both the integrity and authenticity of a message or data transmission. Its primary function is to validate that a message hasn't been tampered with during transmission and originates from a trusted source.

\subsection{HMAC (Hash-based Message Authentication Code)}

HMAC stands for Hash-based Message Authentication Code and is widely adopted for message authentication and integrity verification purposes.\\\\
\textbf{Working Principle:}

\begin{itemize}
\item HMAC takes the message and a secret key as inputs.
\item It utilizes a cryptographic hash function (e.g., SHA-256 or SHA-512) on the message, with the secret key as the hash function's "key".
\item The resulting hash output undergoes further processing to generate the MAC.
\item The MAC produced ensures both the integrity and authenticity of the message.
\end{itemize}

\subsection{CBC-MAC (Cipher Block Chaining Message Authentication Code)}

CBC-MAC, or Cipher Block Chaining Message Authentication Code, is employed for generating a MAC using a block cipher in Cipher Block Chaining (CBC) mode.\\\\
\textbf{Operation:}

\begin{itemize}
\item CBC-MAC processes fixed-size data blocks. If the message surpasses the block size, it is partitioned into blocks.
\item Each block of the message undergoes processing using a symmetric encryption algorithm (e.g., AES) in CBC mode with a secret key.
\item The resultant output of CBC-MAC constitutes the MAC for the entire message, which can be appended to or transmitted with the message for verification purposes.
\item To thwart certain attacks like length extension attacks, CBC-MAC mandates a distinct initialization vector (IV) for each message.
\end{itemize}



\section{Other SHAs}
They are defined in the NIST Standard FIPS (Federal Information Processing Standards) 180-4. Rest of the things we were asked to refer from this PDF: \href{https://csrc.nist.gov/files/pubs/fips/180-2/final/docs/fips180-2.pdf}{\textbf{https://csrc.nist.gov/files/pubs/fips/180-2/final/docs/fips180-2.pdf}}. Below is a small overview of the same.

\subsection{SHA 256}

\textbf{Properties:}
\begin{itemize}
    \item \textbf{Message Size:} $<2^{64}$ bits
    \item \textbf{Block Size:} 512 bits
    \item \textbf{Word Size:} 32 bits
    \item \textbf{Message digest size:} 256 bits
\end{itemize}

\subsection{SHA-512}

\textbf{Properties:}
\begin{itemize}
    \item \textbf{Message Size:} Up to $2^{128}$ bits
    \item \textbf{Block Size:} 1024 bits
    \item \textbf{Word Size:} 64 bits
    \item \textbf{Message Digest Size:} 512 bits
\end{itemize}
\noindent


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%END
 
\end{document}